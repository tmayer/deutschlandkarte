<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Deutschlandkarte</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root {
      color-scheme: dark;
      --bg-gradient: radial-gradient(circle at 25% 20%, #0f172a, #020617 65%);
      --surface: rgba(15, 23, 42, 0.78);
      --border: rgba(148, 163, 184, 0.35);
      --accent: #38bdf8;
      --text-primary: #f8fafc;
      --text-secondary: #cbd5f5;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      min-height: 100%;
      height: 100vh;
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: var(--bg-gradient);
      color: var(--text-primary);
    }

      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: var(--bg-gradient);
      color: var(--text-primary);
    }

    #app {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #map {
      position: absolute;
      inset: 0;
      z-index: 0;
    }

    #overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 400;
    }

    svg.overlay {
      position: absolute;
      overflow: visible;
      pointer-events: none;
    }

    svg.overlay .feature {
      fill: rgba(56, 189, 248, 0.18);
      stroke: rgba(148, 163, 184, 0.65);
      stroke-width: 1;
      cursor: pointer;
      pointer-events: auto;
      transition: fill 0.2s ease, stroke 0.2s ease;
    }

    svg.overlay .feature:hover {
      fill: rgba(56, 189, 248, 0.35);
      stroke: var(--accent);
    }

    svg.overlay .feature.selected,
    svg.overlay .feature.selected.municipality-level {
      fill: rgba(248, 113, 113, 0.35);
      stroke: #fecaca;
    }

    svg.overlay .germany-mask {
      fill: rgba(15, 23, 42, 0.55);
      pointer-events: none;
    }

    svg.overlay .label {
      pointer-events: auto;
      transition: opacity 0.15s ease;
    }

    svg.overlay .label.hidden {
      opacity: 0;
      pointer-events: none;
    }

    svg.overlay .label-name {
      fill: var(--text-primary);
      stroke: rgba(2, 6, 23, 0.7);
      stroke-width: 3;
      paint-order: stroke fill;
      font-weight: 600;
      text-anchor: middle;
      dominant-baseline: middle;
      transition: fill 0.15s ease, stroke 0.15s ease;
    }

    svg.overlay .label.plate-mode .label-name {
      display: none;
    }

    svg.overlay .label-plate {
      display: none;
    }

    svg.overlay .label.plate-mode .label-plate {
      display: block;
    }

    svg.overlay .label-plate rect.plate-bg {
      fill: #f8fafc;
      stroke: none;
    }

    svg.overlay .label-plate .plate-stripe {
      fill: #003399;
      stroke: none;
    }

    svg.overlay .label-plate rect.plate-outline {
      fill: none;
      stroke: rgba(15, 23, 42, 0.7);
      stroke-width: 2;
      stroke-linejoin: round;
    }

    svg.overlay .label-plate text {
      dominant-baseline: middle;
    }

    svg.overlay .label-plate text.plate-text {
      fill: #0f172a;
      font-weight: 700;
      text-anchor: middle;
      letter-spacing: 0.1em;
    }

    svg.overlay .label-plate text.plate-eu,
    svg.overlay .label-plate text.plate-d {
      fill: #ffffff;
      text-anchor: middle;
      font-weight: 600;
    }

    svg.overlay .label.hovered .label-name {
      fill: #1d4ed8;
      stroke: #ffffff;
    }

    svg.overlay .label.hovered .label-plate rect.plate-outline {
      stroke: #2563eb;
      stroke-width: 3;
    }

    .custom-map-controls .leaflet-control-button {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.05rem;
      font-weight: 600;
      color: #0f172a;
    }

    .custom-map-controls .leaflet-control-button.toggle-active {
      background: rgba(148, 163, 184, 0.25);
      color: #1e293b;
    }

    .custom-map-controls .leaflet-control-button.leaflet-disabled {
      color: rgba(15, 23, 42, 0.35);
      pointer-events: none;
    }

    .custom-map-controls .leaflet-control-button.hidden-control {
      display: none;
    }

    .info-panel {
      position: absolute;
      bottom: 1.2rem;
      left: 1.2rem;
      max-width: min(420px, 80vw);
      padding: 0.8rem 1rem;
      border-radius: 0.9rem;
      background: var(--surface);
      border: 1px solid var(--border);
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 36px rgba(15, 23, 42, 0.4);
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      z-index: 1100;
    }

    .info-panel.hidden-panel {
      display: none;
    }

    .info-panel.show-on-mobile {
      display: flex;
    }

    .info-panel strong {
      color: var(--text-primary);
      font-size: 1rem;
    }

    .info-panel span {
      color: var(--text-secondary);
      font-size: 0.85rem;
      line-height: 1.4;
    }

    .loading {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(2, 6, 23, 0.55);
      backdrop-filter: blur(4px);
      z-index: 1050;
      transition: opacity 0.3s ease;
    }

    .loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .spinner {
      width: 52px;
      height: 52px;
      border-radius: 50%;
      border: 4px solid rgba(148, 163, 184, 0.35);
      border-top-color: var(--accent);
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    @media (max-width: 640px) {
      .info-panel {
        display: none;
      }

      .info-panel.show-on-mobile {
        display: flex;
      }
    }

  </style>
</head>
<body>
  <div id="app">
    <div id="map" role="application" aria-label="Drilldown map of Germany"></div>
    <div id="overlay"></div>

    <div class="info-panel" id="info-panel">
      <strong id="info-title">Bundesl√§nder</strong>
      <span id="info-detail">Klicke auf ein Land</span>
    </div>

    <div class="loading hidden" id="loading">
      <div class="spinner" aria-hidden="true"></div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>
  <script>
    const LEVELS = {
      states: {
        file: "topojson/germany_states.json",
        label: "Bundesl√§nder",
        instruction: "Klicke auf ein Land, um die Stadt-/Landkreise anzuzeigen",
        next: "counties",
        prefixLength: 2,
      },
      counties: {
        file: "topojson/germany_counties_with_kfz_full.json",
        label: "Stadt-/Landkreise",
        instruction: "Klicke auf einen Kreis, um die Gemeinden anzuzeigen",
        next: "municipalities",
        prefixLength: 5,
      },
      municipalities: {
        file: "topojson/germany_municipalities.json",
        label: "Gemeinden",
        instruction: "Klicke zur√ºck, um eine Ebene h√∂her zu kommen",
        next: null,
        prefixLength: 12,
      },
    };

    const infoPanel = document.getElementById("info-panel");
    const infoTitle = document.getElementById("info-title");
    const infoDetail = document.getElementById("info-detail");
    const loadingEl = document.getElementById("loading");
    let homeControlButton;
    let backControlButton;
    let labelControlButton;
    let plateControlButton;
    let infoControlButton;
    let infoPanelVisible = true;
    const COUNTY_LABEL_MODES = {
      NAME: "name",
      PLATE: "plate",
    };
    let countyLabelMode = COUNTY_LABEL_MODES.NAME;

    const map = L.map("map", {
      minZoom: 5,
      maxZoom: 13,
      zoomControl: true,
      zoomSnap: 0.25,
      zoomDelta: 0.5,
      wheelPxPerZoomLevel: 90,
      attributionControl: false,
      preferCanvas: true,
    }).setView([51.1657, 10.4515], 6);

    L.tileLayer("https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png", {
      subdomains: "abcd",
      maxZoom: 25,
      attribution:
        '&copy; <a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors &copy; <a href=\"https://carto.com/\">CARTO</a>',
    }).addTo(map);

    const overlayPane = map.getPanes().overlayPane;
    const svg = d3.select(overlayPane)
      .append("svg")
      .attr("class", "overlay leaflet-zoom-animated");
    const root = svg.append("g");
    const maskLayer = root.append("path").attr("class", "germany-mask").attr("fill-rule", "evenodd");
    const featureLayer = root.append("g").attr("class", "feature-layer");
    const labelLayer = root.append("g").attr("class", "label-layer");

    const projector = d3.geoTransform({
      point: function (lng, lat) {
        const point = map.latLngToLayerPoint([lat, lng]);
        this.stream.point(point.x, point.y);
      },
    });

    const path = d3.geoPath().projection(projector);

    let labelsVisible = true;
    let isUserDraggingMap = false;
    let dragEndedAt = 0;
    const DRAG_CLICK_THRESHOLD = 250; // milliseconds to treat a recent drag as non-click

    const cache = {};
    const topoSource = {};
    let displayedFeatures = [];
    let activeCode = null;
    let history = [];
    let currentView = { level: "states", prefix: null, name: "Germany" };
    let germanyMaskFeature = null;

    map.on("move zoom moveend zoomend viewreset", () => window.requestAnimationFrame(syncOverlay));
    map.on("dragstart", () => {
      isUserDraggingMap = true;
    });
    map.on("dragend", () => {
      dragEndedAt = performance.now();
      isUserDraggingMap = false;
    });
    window.addEventListener("resize", () => {
      map.invalidateSize();
      syncOverlay();
      updateInfoPanelVisibility();
    });

    const toolbarControl = L.control({ position: "topleft" });
    toolbarControl.onAdd = () => {
      const container = L.DomUtil.create("div", "leaflet-bar custom-map-controls");
      homeControlButton = createControlButton(container, "üè†", "Zur Startansicht");
      backControlButton = createControlButton(container, "‚Ü©", "Eine Ebene zur√ºck");
      labelControlButton = createControlButton(container, "‚úì", "Labels ausblenden");
      plateControlButton = createControlButton(container, "üöó", "Kfz-Kennzeichen anzeigen");
      infoControlButton = createControlButton(container, "i", "Information ausblenden");
      L.DomEvent.disableClickPropagation(container);
      L.DomEvent.disableScrollPropagation(container);
      return container;
    };
    toolbarControl.addTo(map);
    bindToolbarEvents();
    updateLabelToggleUI();
    updatePlateToggleUI();
    updateLabelVisibility();
    infoPanelVisible = window.innerWidth > 640;
    updateInfoPanelVisibility();
    updateInfoToggleUI();

    function codeFor(feature) {
      return String(feature.properties.RS || feature.properties.AGS || feature.properties.ID_1 || "");
    }

    function nameFor(feature) {
      return feature.properties.GEN || feature.properties.NAME || "Unbenannt";
    }

    function licensePlateFor(feature) {
      const value = feature?.properties?.KFZ;
      return value && String(value).trim().length ? String(value).trim() : "";
    }

    function isCoarsePointerDevice() {
      if (window.matchMedia) {
        try {
          if (window.matchMedia("(pointer: coarse)").matches) {
            return true;
          }
        } catch (error) {}
      }
      return navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    }

    function infoContentFor(feature) {
      const name = nameFor(feature);
      if (currentView.level === "counties") {
        const plate = licensePlateFor(feature);
        if (countyLabelMode === COUNTY_LABEL_MODES.PLATE && plate) {
          return {
            title: plate,
            detail: name,
          };
        }
        return {
          title: name,
          detail: plate ? `KFZ: ${plate}` : "",
        };
      }
      return {
        title: name,
        detail: "",
      };
    }

    function restoreLevelInfo() {
      const meta = LEVELS[currentView.level];
      infoTitle.textContent = formatViewTitle(meta, currentView);
      infoDetail.textContent = LEVELS[currentView.level].instruction;
    }

    function createControlButton(container, symbol, title) {
      const button = L.DomUtil.create("a", "leaflet-control-button", container);
      button.href = "#";
      button.setAttribute("role", "button");
      button.setAttribute("aria-label", title);
      button.title = title;
      button.innerHTML = `<span aria-hidden="true">${symbol}</span>`;
      return button;
    }

    function bindToolbarEvents() {
      if (homeControlButton) {
        L.DomEvent.on(homeControlButton, "click", (event) => {
          L.DomEvent.stop(event);
          goHome();
        });
      }

      if (backControlButton) {
        L.DomEvent.on(backControlButton, "click", (event) => {
          L.DomEvent.stop(event);
          if (backControlButton.classList.contains("leaflet-disabled")) {
            return;
          }
          if (!history.length) {
            goHome();
            return;
          }
          activeCode = null;
          currentView = history.pop();
          loadView(currentView, { skipHistory: true });
        });
      }

      if (labelControlButton) {
        L.DomEvent.on(labelControlButton, "click", (event) => {
          L.DomEvent.stop(event);
          labelsVisible = !labelsVisible;
          updateLabelVisibility();
          updateLabelToggleUI();
        });
      }

      if (plateControlButton) {
        L.DomEvent.on(plateControlButton, "click", (event) => {
          L.DomEvent.stop(event);
          if (currentView.level !== "counties") {
            return;
          }
          countyLabelMode = countyLabelMode === COUNTY_LABEL_MODES.NAME
            ? COUNTY_LABEL_MODES.PLATE
            : COUNTY_LABEL_MODES.NAME;
          updatePlateToggleUI();
          drawFeatures(displayedFeatures);
          restoreLevelInfo();
        });
      }

      if (infoControlButton) {
        L.DomEvent.on(infoControlButton, "click", (event) => {
          L.DomEvent.stop(event);
          infoPanelVisible = !infoPanelVisible;
          updateInfoPanelVisibility();
          updateInfoToggleUI();
        });
      }
    }

    function goHome() {
      history = [];
      activeCode = null;
      currentView = { level: "states", prefix: null, name: "Germany" };
      loadView(currentView);
    }

    function setBackButtonDisabled(disabled) {
      if (!backControlButton) return;
      backControlButton.classList.toggle("leaflet-disabled", disabled);
      backControlButton.setAttribute("aria-disabled", disabled ? "true" : "false");
    }

    function updateLabelToggleUI() {
      if (!labelControlButton) return;
      const labelTitle = labelsVisible ? "Labels ausblenden" : "Labels anzeigen";
      labelControlButton.classList.toggle("toggle-active", labelsVisible);
      labelControlButton.setAttribute("aria-pressed", labelsVisible ? "true" : "false");
      labelControlButton.setAttribute("aria-label", labelTitle);
      labelControlButton.title = labelTitle;
    }

    function updatePlateToggleUI() {
      if (!plateControlButton) return;
      const isCountyLevel = currentView.level === "counties";
      plateControlButton.classList.toggle("hidden-control", !isCountyLevel);
      if (!isCountyLevel) {
        plateControlButton.classList.remove("toggle-active");
        plateControlButton.removeAttribute("aria-pressed");
        plateControlButton.setAttribute("aria-label", "Kfz-Kennzeichen anzeigen");
        plateControlButton.title = "Kfz-Kennzeichen anzeigen";
        return;
      }
      const showingPlates = countyLabelMode === COUNTY_LABEL_MODES.PLATE;
      const plateTitle = showingPlates ? "Landkreisnamen anzeigen" : "Kfz-Kennzeichen anzeigen";
      plateControlButton.classList.toggle("toggle-active", showingPlates);
      plateControlButton.setAttribute("aria-pressed", showingPlates ? "true" : "false");
      plateControlButton.setAttribute("aria-label", plateTitle);
      plateControlButton.title = plateTitle;
    }

    function updateInfoPanelVisibility() {
      if (!infoPanel) return;
      infoPanel.classList.toggle("hidden-panel", !infoPanelVisible);
      if (!infoPanelVisible) {
        infoPanel.classList.remove("show-on-mobile");
        return;
      }
      const isSmallScreen = window.matchMedia
        ? window.matchMedia("(max-width: 640px)").matches
        : window.innerWidth <= 640;
      infoPanel.classList.toggle("show-on-mobile", isSmallScreen);
    }

    function updateInfoToggleUI() {
      if (!infoControlButton) return;
      const infoTitleText = infoPanelVisible ? "Information ausblenden" : "Information anzeigen";
      infoControlButton.classList.toggle("toggle-active", infoPanelVisible);
      infoControlButton.setAttribute("aria-pressed", infoPanelVisible ? "true" : "false");
      infoControlButton.setAttribute("aria-label", infoTitleText);
      infoControlButton.title = infoTitleText;
    }

    function formatViewTitle(meta, view) {
      if (!view || !view.name || view.name === "Germany") {
        return meta.label;
      }
      return `${meta.label} ¬∑ ${view.name}`;
    }

    async function fetchFeatures(level) {
      if (!cache[level]) {
        const response = await fetch(LEVELS[level].file);
        if (!response.ok) {
          throw new Error(`Failed to load ${level} topology.`);
        }
        const data = await response.json();
        topoSource[level] = data;
        const objectName = Object.keys(data.objects)[0];
        cache[level] = topojson.feature(data, data.objects[objectName]).features;
        if (level === "states" && !germanyMaskFeature) {
          const merged = topojson.merge(data, data.objects[objectName].geometries);
          germanyMaskFeature = buildMaskFeature(merged);
        }
      }
      return cache[level];
    }

    function showLoading(show) {
      loadingEl.classList.toggle("hidden", !show);
    }
    async function waitForMapReady() {
      await new Promise((resolve) => map.whenReady(resolve));
      await new Promise((resolve) => requestAnimationFrame(resolve));
    }

    async function loadView(view, { skipHistory = false } = {}) {
      try {
        showLoading(true);
        const featurePromise = fetchFeatures(view.level);
        await waitForMapReady();
        const allFeatures = await featurePromise;
        const filtered = view.prefix
          ? allFeatures.filter((feature) => codeFor(feature).startsWith(view.prefix))
          : allFeatures;

        if (!skipHistory && history.length === 0 && view.level !== "states") {
          history.push({ level: "states", prefix: null, name: "Germany" });
        }

        displayedFeatures = filtered;
        updateUI(view, filtered.length);
        drawFeatures(filtered);
        fitToFeatures(filtered);
      } catch (error) {
        console.error(error);
        infoTitle.textContent = "Data unavailable";
        infoDetail.textContent = error instanceof Error
          ? `${error.message} Refresh the page or verify the TopoJSON files.`
          : "Refresh the page or verify the TopoJSON files.";
      } finally {
        showLoading(false);
      }
    }

    function updateUI(view, count) {
      const meta = LEVELS[view.level];
      const title = formatViewTitle(meta, view);
      infoTitle.textContent = title;
      infoDetail.textContent = meta.instruction;
      setBackButtonDisabled(view.level === "states" && history.length === 0);
      updateLabelToggleUI();
      updatePlateToggleUI();
    }

    function drawFeatures(features) {
      const key = (d) => codeFor(d);
      const isMunicipalityLevel = currentView.level === "municipalities";

      const paths = featureLayer.selectAll("path").data(features, key);

      const pathsEnter = paths
        .enter()
        .append("path")
        .attr("class", "feature");

      paths.exit().remove();

      pathsEnter
        .merge(paths)
        .attr("d", path)
        .classed("selected", (d) => codeFor(d) === activeCode)
        .classed("municipality-level", isMunicipalityLevel)
        .on("click", (event, feature) => {
          event.stopPropagation();
          handleFeatureClick(feature);
        })
        .on("mouseenter", (_, feature) => {
          const info = infoContentFor(feature);
          infoTitle.textContent = info.title;
          infoDetail.textContent = info.detail;
          highlightFeature(codeFor(feature), true);
        })
        .on("mouseleave", (_, feature) => {
          restoreLevelInfo();
          highlightFeature(codeFor(feature), false);
        });

      const shouldLabel = currentView.level !== "states";
      const labelData = shouldLabel
        ? features.map((feature) => ({
            feature,
            code: codeFor(feature),
            name: nameFor(feature),
            licensePlate: licensePlateFor(feature),
          }))
        : [];

      const labels = labelLayer.selectAll("g.label").data(labelData, (d) => d.code);

      labels.exit().remove();

      const labelsEnter = labels
        .enter()
        .append("g")
        .attr("class", "label")
        .call((selection) => {
          selection.append("text").attr("class", "label-name");
          const plate = selection.append("g").attr("class", "label-plate");
          plate.append("rect").attr("class", "plate-bg");
          plate.append("path").attr("class", "plate-stripe");
          plate.append("rect").attr("class", "plate-outline");
          plate.append("text").attr("class", "plate-eu").text("üá™üá∫");
          plate.append("text").attr("class", "plate-d").text("D");
          plate.append("text").attr("class", "plate-text");
        });

      const labelsMerged = labelsEnter.merge(labels);

      labelsMerged
        .attr("data-code", (d) => d.code)
        .on("mouseenter", (_, d) => {
          const info = infoContentFor(d.feature);
          infoTitle.textContent = info.title;
          infoDetail.textContent = info.detail;
          highlightFeature(d.code, true);
        })
        .on("mouseleave", (_, d) => {
          restoreLevelInfo();
          highlightFeature(d.code, false);
        })
        .on("click", (event, d) => {
          event.stopPropagation();
          handleFeatureClick(d.feature);
        });

      syncOverlay();
    }

    function isPlateModeActive() {
      return currentView.level === "counties" && countyLabelMode === COUNTY_LABEL_MODES.PLATE;
    }

    function refreshLabels() {
      const zoom = map.getZoom();
      const plateModeActive = isPlateModeActive();

      labelLayer.selectAll("g.label").each(function (d) {
        const group = d3.select(this);
        const centroid = path.centroid(d.feature);
        const fontSize = fontSizeFor(d.feature, currentView.level, zoom);
        const radius = anchorRadiusFor(currentView.level);
        const labelHasPlate = Boolean(d.licensePlate);
        const plateVisible = plateModeActive && labelHasPlate;

        group
          .attr("data-code", d.code)
          .attr("transform", `translate(${centroid[0]}, ${centroid[1] - radius - 2})`)
          .classed("plate-mode", plateVisible)
          .classed("name-mode", !plateVisible);

        group.select("text.label-name")
          .style("font-size", `${fontSize}px`)
          .text(d.name);

        const plateGroup = group.select("g.label-plate");
        if (!plateGroup.empty()) {
          const plateTextValue = d.licensePlate || d.name;
          const baseFont = Math.max(11, fontSize * 0.82);
          const plateHeight = Math.max(20, baseFont * 1.55);
          const stripeWidth = Math.max(10, plateHeight * 0.3);
          const textSelection = plateGroup.select("text.plate-text")
            .style("font-size", `${baseFont}px`)
            .attr("lengthAdjust", null)
            .attr("textLength", null)
            .style("letter-spacing", null)
            .text(plateTextValue);
          const charCount = plateTextValue.length;
          const approximateWidth = charCount
            ? (charCount * baseFont * 0.88) + Math.max(charCount - 1, 0) * (baseFont * 0.18)
            : baseFont * 2.6;
          let measuredTextWidth = approximateWidth;
          const textNode = textSelection.node();
          if (textNode && typeof textNode.getComputedTextLength === "function") {
            const computed = textNode.getComputedTextLength();
            if (Number.isFinite(computed) && computed > 0) {
              measuredTextWidth = computed;
            }
          }
          const horizontalPadding = Math.max(baseFont * 0.45, 14);
          const minContentWidth = plateHeight * 1.65;
          const contentWidth = Math.max(measuredTextWidth + horizontalPadding * 2, minContentWidth);
          const availableTextWidth = Math.max(contentWidth - horizontalPadding * 2, plateHeight);
          if (measuredTextWidth > availableTextWidth) {
            const adjustedLetterSpacing = Math.max(0.04, 0.1 - ((measuredTextWidth - availableTextWidth) / measuredTextWidth) * 0.06);
            textSelection
              .attr("lengthAdjust", "spacingAndGlyphs")
              .attr("textLength", availableTextWidth)
              .style("letter-spacing", `${adjustedLetterSpacing.toFixed(3)}em`);
          }
          const plateWidth = stripeWidth + contentWidth;
          const plateRadius = plateHeight * 0.2;

          plateGroup.attr("transform", `translate(${-plateWidth / 2}, ${-plateHeight / 2})`);

          plateGroup.select("rect.plate-bg")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", plateWidth)
            .attr("height", plateHeight)
            .attr("rx", plateRadius)
            .attr("ry", plateRadius);

          plateGroup.select("path.plate-stripe")
            .attr("d", [
              `M${stripeWidth},0`,
              `H${plateRadius}`,
              `A${plateRadius},${plateRadius} 0 0 0 0,${plateRadius}`,
              `V${plateHeight - plateRadius}`,
              `A${plateRadius},${plateRadius} 0 0 0 ${plateRadius},${plateHeight}`,
              `H${stripeWidth}`,
              "Z"
            ].join(" "));

          plateGroup.select("rect.plate-outline")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", plateWidth)
            .attr("height", plateHeight)
            .attr("rx", plateRadius)
            .attr("ry", plateRadius);

          plateGroup.select("text.plate-text")
            .attr("x", stripeWidth + (plateWidth - stripeWidth) / 2)
            .attr("y", plateHeight / 2);

          plateGroup.select("text.plate-eu")
            .attr("x", stripeWidth / 2)
            .attr("y", plateHeight * 0.35)
            .style("font-size", `${plateHeight * 0.42}px`);

          plateGroup.select("text.plate-d")
            .attr("x", stripeWidth / 2)
            .attr("y", plateHeight * 0.75)
            .style("font-size", `${plateHeight * 0.38}px`);
        }
      });
    }

    function labelArea(feature) {
      const bbox = path.bounds(feature);
      const width = Math.max(1, bbox[1][0] - bbox[0][0]);
      const height = Math.max(1, bbox[1][1] - bbox[0][1]);
      return width * height;
    }

    function fontSizeFor(feature, level, zoom) {
      const base = { states: 18, counties: 15, municipalities: 13 }[level] || 14;
      const zoomScale = base + (zoom - 6) * 1.1;
      const area = labelArea(feature);
      const target = Math.sqrt(area) * 0.12;
      const size = Math.min(zoomScale, target);
      const minSize = { states: 12, counties: 10, municipalities: 8 }[level] || 10;
      const maxSize = { states: 28, counties: 22, municipalities: 18 }[level] || 20;
      return Math.max(minSize, Math.min(maxSize, size));
    }

    function anchorRadiusFor(level) {
      return { states: 5, counties: 4, municipalities: 3 }[level] || 4;
    }

    function highlightFeature(code, active) {
      const selection = labelLayer
        .selectAll(`g.label[data-code="${code}"]`)
        .classed('hovered', active)
        .classed('hidden', function () {
          return !labelsVisible && !active;
        });

      if (active) {
        selection.each(function () {
          if (this.parentNode) {
            this.parentNode.appendChild(this);
          }
        });
      }

      updateLabelVisibility();
    }

    function updateLabelVisibility() {
      labelLayer
        .selectAll('g.label')
        .classed('hidden', function () {
          return !labelsVisible && !d3.select(this).classed('hovered');
        });
    }

    function syncOverlay() {
      if (!displayedFeatures.length) return;

      const featureCollection = { type: "FeatureCollection", features: displayedFeatures };
      const bounds = path.bounds(featureCollection);
      const topLeft = bounds[0];
      const bottomRight = bounds[1];

      svg
        .attr("width", Math.max(1, bottomRight[0] - topLeft[0]))
        .attr("height", Math.max(1, bottomRight[1] - topLeft[1]))
        .style("left", `${topLeft[0]}px`)
        .style("top", `${topLeft[1]}px`);

      root.attr("transform", `translate(${-topLeft[0]}, ${-topLeft[1]})`);

      if (germanyMaskFeature) {
        maskLayer.attr("d", path(germanyMaskFeature));
      }

      featureLayer
        .selectAll("path")
        .attr("d", path)
        .classed("selected", (d) => codeFor(d) === activeCode)
        .classed("municipality-level", currentView.level === "municipalities");

      refreshLabels();

      updateLabelVisibility();
    }

    function fitToFeatures(features) {
      if (!features.length) return;
      const featureCollection = { type: "FeatureCollection", features };
      const bounds = d3.geoBounds(featureCollection);
      const sw = L.latLng(bounds[0][1], bounds[0][0]);
      const ne = L.latLng(bounds[1][1], bounds[1][0]);
      const padding = window.innerWidth < 768 ? [0, 0] : [0, 0];
      map.fitBounds(L.latLngBounds(sw, ne), { padding });
    }

    function handleFeatureClick(feature) {
      const now = performance.now();
      if (isUserDraggingMap || (dragEndedAt && now - dragEndedAt < DRAG_CLICK_THRESHOLD)) {
        return;
      }
      const meta = LEVELS[currentView.level];
      const nextLevel = meta.next;
      const code = codeFor(feature);
      const name = nameFor(feature);

      if (isCoarsePointerDevice() && currentView.level === "counties" && nextLevel) {
        if (activeCode !== code) {
          const previousCode = activeCode;
          activeCode = code;
          const info = infoContentFor(feature);
          infoTitle.textContent = info.title;
          infoDetail.textContent = info.detail;
          if (previousCode && previousCode !== code) {
            highlightFeature(previousCode, false);
          }
          highlightFeature(code, true);
          syncOverlay();
          return;
        }
      }

      if (!nextLevel) {
        const previousCode = activeCode;
        activeCode = code;
        infoTitle.textContent = name;
        infoDetail.textContent = "";
        if (previousCode && previousCode !== code) {
          highlightFeature(previousCode, false);
        }
        highlightFeature(code, true);
        syncOverlay();
        return;
      }

      activeCode = code;

      history.push({ ...currentView });

      currentView = {
        level: nextLevel,
        prefix: code.slice(0, meta.prefixLength),
        name,
      };

      loadView(currentView, { skipHistory: true });
    }

    function buildMaskFeature(merged) {
      const outerRing = [
        [-180, -90],
        [180, -90],
        [180, 90],
        [-180, 90],
        [-180, -90],
      ];
      let rings = [];
      const geometry = merged && merged.type ? merged : merged?.geometry;
      if (!geometry) {
        return null;
      }
      if (geometry.type === "Polygon") {
        rings = geometry.coordinates;
      } else if (geometry.type === "MultiPolygon") {
        rings = geometry.coordinates.flat();
      }
      return {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [outerRing, ...rings],
        },
      };
    }

    map.whenReady(() => {
      loadView(currentView);
    });
  </script>
</body>
</html>
